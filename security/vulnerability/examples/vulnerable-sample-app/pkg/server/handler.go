package server

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"
)

func (s *Server) index() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/top", http.StatusFound)
	}
}

func (s *Server) getLogin() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		_, err := r.Cookie("session_id")
		if err == nil {
			http.Redirect(w, r, "/welcome", http.StatusFound)
		}

		w.Write([]byte(`<h1>Login</h1>
<form method="post" action="/login">
    <label for="name">User name</label>
    <input type="text" id="username" name="username">
    <label for="password">Password</label>
    <input type="password" id="password" name="password">
    <button type="submit">Login</button>
</form>`))
	}
}

// TODO: こういうアクションはログを取るべきはずで、それは middleware に任せられるのか？
func (s *Server) postLogin() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		err := r.ParseForm()
		if err != nil {
			log.Println("[Error] Failed to parse form")
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		username := r.PostForm.Get("username")
		password := r.PostForm.Get("password")
		// TODO: make these codes func or something
		query := "select password from users where username = ?"
		var expectedPass string
		if err := s.db.QueryRowContext(context.Background(), query, username).Scan(&expectedPass); err != nil {
			log.Printf("[Error] Failed to get password from user %s", username)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		// TODO: add hash/salt and verify
		if password != expectedPass {
			log.Printf("[Error] Failed to find user/password pair %s/%s", username, password)
			w.WriteHeader(http.StatusBadRequest)
			return
		}

		sessionID := getSessionID()
		s.db.ExecContext(context.Background(), "i")
		tx, err := s.db.Begin()
		if err != nil {
			log.Println("[Error] Failed to start transaction")
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		// TODO: このあたりの tx の扱いについて
		expired := time.Now().Add(5 * time.Minute)
		_, err = tx.Exec("insert into session (id, username, expired_at) VALUES (?, ?, ?) on duplicate key update username=?", sessionID, username, expired.Unix(), username)
		if err != nil {
			log.Printf("[Error] Failed to insert session %s", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}
		if err = tx.Commit(); err != nil {
			log.Printf("[Error] Failed to insert session %s", err)
			w.WriteHeader(http.StatusInternalServerError)
			return
		}

		cookie := &http.Cookie{
			Name:    "session_id",
			Value:   sessionID,
			Expires: time.Now().Add(5 * time.Minute),
		}
		http.SetCookie(w, cookie)

		http.Redirect(w, r, "/welcome", http.StatusFound)
	}
}

func (s *Server) postLogout() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		clearSessionID(w)
		http.Redirect(w, r, "/top", http.StatusFound)
	}
}

func (s *Server) welcome() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Welcome")
	}
}

func (s *Server) healthy() http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if err := s.db.Ping(); err != nil {
			// TODO: 503 で良いかどうか
			log.Printf("[Error] Could not ping db %s", err)
			w.WriteHeader(http.StatusServiceUnavailable)
			fmt.Fprintf(w, "App is UnHealthy.\n")
			return
		}

		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "App is Healthy.\n")
	}
}

func getSessionID() string {
	b := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return ""
	}
	return base64.URLEncoding.EncodeToString(b)
}

func clearSessionID(response http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:   "session_id",
		Value:  "",
		Path:   "/",
		MaxAge: -1,
	}
	http.SetCookie(response, cookie)
}
