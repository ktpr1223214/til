package server

import (
	"context"
	"github.com/ktpr1223214/til/security/vulnerability/examples/vulnerable-sample-app/pkg/model"
	"go.uber.org/zap"
	"math/rand"
	"net/http"
	"time"
)

const requestKey = "request_id"

func (s *Server) loginOnly(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !isUserAuthenticated(r) {
			http.Redirect(w, r, "/top", http.StatusFound)
			return
		}
		h.ServeHTTP(w, r)
	})
}

func (s *Server) checkSession(h http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		// TODO: impl
		// 存在チェック
		// 無い場合は、redirect?
		// ある場合は、期限を確認・問題なければ update
		// 問題あればやっぱ redirect?
		sessionID, err := r.Cookie(sessionKey)
		if err != nil {
			// TODO: これ適切かどうか
			http.Error(w, err.Error(), http.StatusUnauthorized)
			return
		}

		// server side で　session がどうなっているかを確認(場合によっては消されているかも)
		var session model.Session
		if err := s.db.QueryRowContext(context.Background(), "select * from session where id = ?", sessionID.Value).Scan(&session); err != nil {
			clearSessionID(w)
			http.Redirect(w, r, "/top", http.StatusFound)
		}

		/*
			expired := time.Now().Add(5 * time.Minute)
			if expired.Unix() >= session.ExpiredAt {
				user := types.User{}
				err = db.Get(&user, "SELECT * FROM users WHERE username=?", session.Username)
				if err != nil {
					return err
				}
				_, err = db.Query("UPDATE session SET expired_at = ? WHERE id = ?", expired.Unix(), session.ID)
				if err != nil {
					return err
				}

				cookie := &http.Cookie{
					Name:    "session_id",
					Value:   session.ID,
					// TODO: これ expired と同じにしないとでは？
					Expires: time.Now().Add(5 * time.Minute),
				}
				http.SetCookie(w, cookie)

				c.Set("user", &user)
			} else {
				_, err = db.Query("DELETE FROM session WHERE id = ?", sessionId.Value)
				if err != nil {
					return err
				}
				cookie := new(http.Cookie)
				cookie.Name = "session_id"
				cookie.Value = ""
				cookie.MaxAge = -1
				c.SetCookie(cookie)
			}

			if err := next(c); err != nil {
				log.Errorf("error: %v", err)
				c.Error(err)
			}*/

		h(w, r)
	}
}

func addRequestID(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		rid := newRequestID()
		ctx := r.Context()

		h.ServeHTTP(w, r.WithContext(context.WithValue(ctx, requestKey, rid)))
	})
}

func withLogRequest(l *zap.Logger) func(h http.Handler) http.Handler {
	return func(h http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			start := time.Now()
			h.ServeHTTP(w, r)
			elapsed := time.Since(start)

			l.Info(
				"Completed",
				zap.String("method", r.Method),
				zap.String("url", r.RequestURI),
				zap.String("proto", r.Proto),
				zap.Duration("elapsed", elapsed),
				zap.String("req_id", r.Context().Value(requestKey).(string)),
			)
		})
	}
}

func newRequestID() string {
	var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	b := make([]rune, 8)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

// TODO: check serverside session state
func isUserAuthenticated(r *http.Request) bool {
	_, err := r.Cookie(sessionKey)
	return err == nil
}
