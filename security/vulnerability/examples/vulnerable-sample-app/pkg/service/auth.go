package service

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"github.com/ktpr1223214/til/security/vulnerability/examples/vulnerable-sample-app/pkg/model"
	"github.com/pkg/errors"
	"io"
	"log"
	"time"
)

const (
	sessionKey = "session_id"
)

type AuthService interface {
	SetSession(username string, expiration time.Duration) (string, error)
	DeleteSession(sessionID string) error
	CheckPassword(ctx context.Context, username string, password string) (bool, error)
	PeriodicCleanup(interval time.Duration, quit <-chan struct{})
}

type authService struct {
	sessionRepo SessionRepository
	userRepo    UserRepository
}

type SessionRepository interface {
	SetSession(id string, username string, expiration time.Duration) error
	GetSession(sessionID string) (*model.Session, error)
	DeleteSession(sessionID string) error
	DeleteUnusedSession() error
}

type UserRepository interface {
	GetUsrPass(ctx context.Context, username string) (string, error)
}

func NewAuthService(sessionRepo SessionRepository, userRepo UserRepository) AuthService {
	return &authService{
		sessionRepo: sessionRepo,
		userRepo:    userRepo,
	}
}

func (a *authService) SetSession(username string, expiration time.Duration) (string, error) {
	sessionID := getSessionID()
	if err := a.sessionRepo.SetSession(sessionID, username, expiration); err != nil {
		return "", err
	}

	return sessionID, nil
}

func (a *authService) CheckPassword(ctx context.Context, username string, password string) (bool, error) {
	expectedPass, err := a.userRepo.GetUsrPass(context.Background(), username)
	if err != nil {
		return false, err
	}
	// TODO: add hash/salt and verify
	if password != expectedPass {
		return false, errors.New(fmt.Sprintf("failed to find user/password pair %s/%s", username, password))
	}

	return true, nil
}

func (a *authService) DeleteSession(sessionID string) error {
	if err := a.sessionRepo.DeleteSession(sessionID); err != nil {
		return err
	}

	return nil
}

func getSessionID() string {
	b := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return ""
	}
	return base64.URLEncoding.EncodeToString(b)
}

func (a *authService) PeriodicCleanup(interval time.Duration, quit <-chan struct{}) {
	t := time.NewTicker(interval)
	defer t.Stop()
	for {
		select {
		case <-t.C:
			if err := a.sessionRepo.DeleteUnusedSession(); err != nil {
				log.Printf("[Error] Failed to delete unused session %s", err)
			}
			log.Println("Delete unused sessions")
		case <-quit:
			return
		}
	}
}
