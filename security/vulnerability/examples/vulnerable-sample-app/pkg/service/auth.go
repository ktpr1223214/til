package service

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"github.com/ktpr1223214/til/security/vulnerability/examples/vulnerable-sample-app/pkg/model"
	"github.com/pkg/errors"
	"io"
	"net/http"
	"time"
)

const (
	sessionKey = "session_id"
	expiration = time.Minute * 5
)

type AuthService interface {
	SetSession(w http.ResponseWriter, username string) error
	DeleteSession(w http.ResponseWriter, sessionID string) error
	CheckPassword(ctx context.Context, username string, password string) (bool, error)
}

type authService struct {
	sessionRepo SessionRepository
	userRepo    UserRepository
	expiration  time.Duration
}

type SessionRepository interface {
	SetSession(id string, username string, expiration time.Duration) error
	GetSession(sessionID string) (*model.Session, error)
	DeleteSession(sessionID string) error
}

type UserRepository interface {
	GetUsrPass(ctx context.Context, username string) (string, error)
}

func NewAuthSerivce(sessionRepo SessionRepository, userRepo UserRepository, expiration time.Duration) AuthService {
	return &authService{
		sessionRepo: sessionRepo,
		userRepo:    userRepo,
		expiration:  expiration,
	}
}

func (a *authService) SetSession(w http.ResponseWriter, username string) error {
	sessionID := getSessionID()
	if err := a.sessionRepo.SetSession(sessionID, username, a.expiration); err != nil {
		return err
	}

	cookie := &http.Cookie{
		Name:    sessionKey,
		Value:   sessionID,
		Expires: time.Now().Add(a.expiration),
	}
	http.SetCookie(w, cookie)

	return nil
}

func (a *authService) CheckPassword(ctx context.Context, username string, password string) (bool, error) {
	expectedPass, err := a.userRepo.GetUsrPass(context.Background(), username)
	if err != nil {
		return false, err
	}
	// TODO: add hash/salt and verify
	if password != expectedPass {
		return false, errors.New(fmt.Sprintf("failed to find user/password pair %s/%s", username, password))
	}

	return true, nil
}

func (a *authService) DeleteSession(w http.ResponseWriter, sessionID string) error {
	if err := a.sessionRepo.DeleteSession(sessionID); err != nil {
		return err
	}
	clearSessionID(w)

	return nil
}

func getSessionID() string {
	b := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return ""
	}
	return base64.URLEncoding.EncodeToString(b)
}

func clearSessionID(response http.ResponseWriter) {
	cookie := &http.Cookie{
		Name:   sessionKey,
		Value:  "",
		Path:   "/",
		MaxAge: -1,
	}
	http.SetCookie(response, cookie)
}
